const { pool } = require('../config/database');

class SmartRetrySystem {
    constructor() {
        // SYST√àME SIMPLIFI√â: Basculement syst√©matique vers autre SIM en cas d'√©chec
        this.timeoutMessages = new Map(); // Gestion des timeouts
        this.processingQueue = new Set(); // Messages en cours de traitement
    }

    /**
     * G√®re l'√©chec d'un message et d√©cide de la strat√©gie de retry
     */
    async handleFailedMessage(messageId, errorCode, phoneId = null, simId = null) {
        console.log(`üîÑ D√âBUT Gestion √©chec message ${messageId}: ${errorCode}`);
        
        try {
            // R√©cup√©rer les informations du message
            const message = await this.getMessageById(messageId);
            if (!message) {
                console.error(`‚ùå Message ${messageId} non trouv√©`);
                return false;
            }

            console.log(`üìã Message trouv√©: ID=${message.id}, SIM=${message.sim_id}, Phone=${message.phone_id}, Retry=${message.retry_count}, Status=${message.status}`);

            // D√âSACTIVATION SYST√âMATIQUE: D√©sactiver imm√©diatement la SIM d√©faillante (sauf si exclue du monitoring)
            if (message.sim_id) {
                // V√©rifier si la SIM est exclue du monitoring
                const [simInfo] = await pool.execute(
                    'SELECT excluded_from_monitoring FROM sims WHERE id = ?',
                    [message.sim_id]
                );
                
                if (simInfo.length > 0 && simInfo[0].excluded_from_monitoring === 1) {
                    console.log(`üõ°Ô∏è SIM ${message.sim_id} exclue du monitoring - d√©sactivation ignor√©e`);
                } else {
                    await pool.execute(
                        'UPDATE sims SET is_active = 0, is_default = 0 WHERE id = ?',
                        [message.sim_id]
                    );
                    console.log(`‚ùå SIM ${message.sim_id} d√©sactiv√©e suite √† l'√©chec du message ${messageId} (SYST√âMATIQUE)`);
                    
                    // IMM√âDIATEMENT d√©finir une nouvelle SIM par d√©faut pour permettre le retry
                    await this.setNewDefaultSimAfterFailure(message.phone_id, message.sim_id);
                }
            }

            // SYST√àME SIMPLIFI√â: Toujours essayer de basculer vers une autre SIM
            console.log(`üìã √âchec d√©tect√© - Basculement automatique vers une autre SIM`);

            // La nouvelle SIM par d√©faut a d√©j√† √©t√© d√©finie, pas besoin de v√©rifier la disponibilit√©
            console.log(`‚úÖ Nouvelle SIM par d√©faut d√©finie, proc√©dure de retry autoris√©e`);

            // S√©curit√© : arr√™t apr√®s 10 tentatives maximum pour √©viter les boucles infinies
            if (message.retry_count >= 10) {
                console.log(`‚õî Message ${messageId}: Arr√™t de s√©curit√© apr√®s ${message.retry_count} tentatives`);
                await this.markMessageAsFinalFailure(messageId, errorCode);
                return false;
            }

            // Incr√©menter le compteur de retry
            await this.incrementRetryCount(messageId);

            // TOUJOURS basculer vers une autre SIM en cas d'√©chec
            console.log(`üîÑ Lancement du retry avec SIM diff√©rente pour message ${messageId}`);
            const retryResult = await this.retryWithDifferentSim(messageId, message, { switchSim: true });
            console.log(`üìã R√©sultat du retry: ${retryResult ? 'SUCC√àS' : '√âCHEC'}`);
            return retryResult;

        } catch (error) {
            console.error(`‚ùå Erreur lors de la gestion d'√©chec:`, error);
            return false;
        }
    }

    /**
     * Retry avec basculement vers une autre SIM
     */
    async retryWithDifferentSim(messageId, message, strategy) {
        console.log(`üîÑ D√âBUT Basculement SIM pour message ${messageId} (SIM ${message.sim_id} d√©j√† d√©sactiv√©e)`);
        
        try {
            // Chercher la SIM par d√©faut actuelle (qui a √©t√© d√©finie dans setNewDefaultSimAfterFailure)
            console.log(`üîç Recherche de la SIM par d√©faut actuelle...`);
            const [defaultSims] = await pool.execute(`
                SELECT id, phone_number, carrier_name, phone_id 
                FROM sims 
                WHERE is_default = 1 AND is_active = 1 
                LIMIT 1
            `);
            
            console.log(`üìã SIMs par d√©faut trouv√©es: ${defaultSims.length}`);
            
            if (defaultSims.length > 0) {
                const newDefaultSim = defaultSims[0];
                console.log(`‚úÖ SIM par d√©faut trouv√©e: ${newDefaultSim.id} (${newDefaultSim.phone_number || 'N/A'} ${newDefaultSim.carrier_name}) - D√âJ√Ä ACTIVE sur t√©l√©phone ${newDefaultSim.phone_id}`);
                
                // Cr√©er un NOUVEAU message avec la SIM par d√©faut et le bon phone_id
                console.log(`üìù Cr√©ation du nouveau message...`);
                const newMessageId = await this.createNewMessageWithCorrectPhone(message, newDefaultSim.id, newDefaultSim.phone_id);
                console.log(`‚úÖ SUCC√àS: Nouveau message ${newMessageId} cr√©√© avec SIM par d√©faut ${newDefaultSim.id} sur t√©l√©phone ${newDefaultSim.phone_id}`);
                
                return true;
            } else {
                // Aucune SIM par d√©faut disponible, essayer sur un autre t√©l√©phone
                console.log(`‚ö†Ô∏è Aucune SIM par d√©faut trouv√©e - Tentative sur autre t√©l√©phone pour message ${messageId}`);
                return await this.retryWithDifferentPhone(messageId, message, strategy);
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur lors du basculement SIM:`, error);
            return false;
        }
    }

    // FONCTION SUPPRIM√âE: retryWithDelay
    // Le syst√®me simplifi√© ne fait que basculer vers une autre SIM

    /**
     * Retry sur un t√©l√©phone diff√©rent
     */
    async retryWithDifferentPhone(messageId, message, strategy) {
        console.log(`üì± Recherche t√©l√©phone alternatif pour message ${messageId}`);
        
        try {
            const alternativePhone = await this.selectAlternativePhone(message.phone_id);
            
            if (alternativePhone) {
                console.log(`‚úÖ T√©l√©phone alternatif trouv√©: ${alternativePhone.phone_id}`);
                
                // Cr√©er un nouveau message sur le t√©l√©phone alternatif
                const newMessageId = await this.createNewMessageWithPhone(message, alternativePhone.phone_id, alternativePhone.best_sim_id);
                console.log(`üìù Nouveau message ${newMessageId} cr√©√© sur t√©l√©phone ${alternativePhone.phone_id}`);
                
                return true;
            } else {
                console.log(`‚ùå Aucun t√©l√©phone alternatif disponible`);
                await this.markMessageAsFinalFailure(messageId, 'NO_ALTERNATIVE_DEVICE');
                return false;
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur lors du changement de t√©l√©phone:`, error);
            return false;
        }
    }

    /**
     * S√©lectionne la meilleure SIM alternative
     */
    async selectAlternativeSim(currentSimId, phoneId, message = null) {
        try {
            console.log(`üîç Recherche SIM alternative (actuelle: ${currentSimId}, t√©l√©phone: ${phoneId})`);
            
            // NOUVELLE LOGIQUE: D'abord essayer les SIMs non test√©es pour ce destinataire
            if (message && message.recipient) {
                const untestedSims = await this.getUntestedActiveSims(message.recipient);
                if (untestedSims.length > 0) {
                    const selectedSim = untestedSims[0];
                    console.log(`üéØ SIM non test√©e s√©lectionn√©e: ${selectedSim.id} (${selectedSim.carrier_name} ${selectedSim.phone_number || 'N/A'})`);
                    return selectedSim.id;
                }
                console.log(`‚ö†Ô∏è Aucune SIM non test√©e disponible, utilisation logique classique`);
            }
            
            // Logique classique avec quotas d√©sactiv√©s
            const [availableSims] = await pool.query(`
                SELECT s.id, s.carrier_name, s.messages_sent_month, s.monthly_limit,
                       s.recipients_monthly, s.recipients_monthly_limit,
                       COALESCE(ss.success_rate, 95) as success_rate,
                       COALESCE(ss.avg_response_time, 5000) as avg_response_time
                FROM sims s
                LEFT JOIN sim_stats ss ON s.id = ss.sim_id
                WHERE s.phone_id = ? 
                  AND s.id != ? 
                  AND s.is_active = true
                ORDER BY 
                    ss.success_rate DESC,
                    s.messages_sent_month ASC,
                    ss.avg_response_time ASC
                LIMIT 1
            `, [phoneId, currentSimId]);

            if (availableSims.length > 0) {
                console.log(`‚úÖ SIM alternative trouv√©e sur le m√™me t√©l√©phone: ${availableSims[0].id}`);
                return availableSims[0].id;
            }

            // Si pas de SIM alternative sur le m√™me t√©l√©phone, essayer sur d'autres t√©l√©phones
            console.log(`üîÑ Recherche SIM sur d'autres t√©l√©phones...`);
            const [otherPhoneSims] = await pool.query(`
                SELECT s.id, s.carrier_name, s.phone_number, s.phone_id,
                       COALESCE(ss.success_rate, 95) as success_rate,
                       COALESCE(ss.avg_response_time, 5000) as avg_response_time
                FROM sims s
                LEFT JOIN sim_stats ss ON s.id = ss.sim_id
                JOIN phones p ON s.phone_id = p.id
                WHERE p.status = 'active'
                  AND s.id != ? 
                  AND s.is_active = true
                ORDER BY 
                    ss.success_rate DESC,
                    s.messages_sent_month ASC,
                    ss.avg_response_time ASC
                LIMIT 1
            `, [currentSimId]);

            return otherPhoneSims.length > 0 ? otherPhoneSims[0].id : null;
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la s√©lection SIM alternative:`, error);
            return null;
        }
    }

    /**
     * S√©lectionne un t√©l√©phone alternatif
     */
    async selectAlternativePhone(currentPhoneId) {
        try {
            console.log(`üîç Recherche t√©l√©phone alternatif (actuel: ${currentPhoneId})`);
            
            const [alternativePhones] = await pool.query(`
                SELECT p.id as phone_id, 
                       MIN(s.id) as best_sim_id,
                       COUNT(s.id) as sim_count,
                       AVG(COALESCE(ss.success_rate, 95)) as avg_success_rate
                FROM phones p
                INNER JOIN sims s ON p.id = s.phone_id
                LEFT JOIN sim_stats ss ON s.id = ss.sim_id
                WHERE p.id != ?
                  AND p.status = 'active'
                  AND p.last_heartbeat > DATE_SUB(NOW(), INTERVAL 5 MINUTE)
                  AND s.is_active = true
                  AND s.messages_sent_month < s.monthly_limit * 0.9
                GROUP BY p.id
                HAVING sim_count > 0
                ORDER BY avg_success_rate DESC, sim_count DESC
                LIMIT 1
            `, [currentPhoneId]);

            console.log(`üìä T√©l√©phones alternatifs trouv√©s: ${alternativePhones.length}`);
            
            if (alternativePhones.length === 0) {
                // Diagnostiquer pourquoi aucun t√©l√©phone n'est trouv√©
                const [allPhones] = await pool.query(`
                    SELECT p.id, p.status, p.last_heartbeat,
                           COUNT(s.id) as total_sims,
                           COUNT(CASE WHEN s.is_active = true THEN 1 END) as active_sims
                    FROM phones p
                    LEFT JOIN sims s ON p.id = s.phone_id
                    WHERE p.id != ?
                    GROUP BY p.id, p.status, p.last_heartbeat
                `, [currentPhoneId]);
                
                console.log(`üîç Tous les autres t√©l√©phones (${allPhones.length}):`, allPhones);
            }

            return alternativePhones.length > 0 ? alternativePhones[0] : null;
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la s√©lection t√©l√©phone alternatif:`, error);
            return null;
        }
    }

    /**
     * Cr√©e un nouveau message avec une SIM diff√©rente
     */
    async createNewMessageWithSim(originalMessage, newSimId) {
        try {
            const [result] = await pool.execute(`
                INSERT INTO sms_history (
                    phone_id, recipient, message, sim_id, status, 
                    retry_count, created_at, updated_at
                ) VALUES (?, ?, ?, ?, 'pending', ?, NOW(), NOW())
            `, [
                originalMessage.phone_id,
                originalMessage.recipient,
                originalMessage.message,
                newSimId,
                (originalMessage.retry_count || 0) + 1
            ]);
            
            return result.insertId;
        } catch (error) {
            console.error(`‚ùå Erreur lors de la cr√©ation du nouveau message:`, error);
            throw error;
        }
    }

    /**
     * Cr√©e un nouveau message avec la SIM et le t√©l√©phone corrects
     */
    async createNewMessageWithCorrectPhone(originalMessage, newSimId, newPhoneId) {
        try {
            console.log(`üìù Cr√©ation nouveau message: SIM ${newSimId} sur t√©l√©phone ${newPhoneId}`);
            
            const [result] = await pool.execute(`
                INSERT INTO sms_history (
                    phone_id, recipient, message, sim_id, status, 
                    retry_count, created_at, updated_at
                ) VALUES (?, ?, ?, ?, 'pending', ?, NOW(), NOW())
            `, [
                newPhoneId,  // Utiliser le phone_id de la nouvelle SIM
                originalMessage.recipient,
                originalMessage.message,
                newSimId,
                (originalMessage.retry_count || 0) + 1
            ]);
            
            console.log(`‚úÖ Nouveau message ${result.insertId} cr√©√© avec SIM ${newSimId} sur t√©l√©phone ${newPhoneId}`);
            return result.insertId;
        } catch (error) {
            console.error(`‚ùå Erreur lors de la cr√©ation du nouveau message avec t√©l√©phone correct:`, error);
            throw error;
        }
    }

    /**
     * Cr√©e un nouveau message avec un t√©l√©phone diff√©rent
     */
    async createNewMessageWithPhone(originalMessage, newPhoneId, newSimId) {
        try {
            const [result] = await pool.execute(`
                INSERT INTO sms_history (
                    phone_id, recipient, message, sim_id, status, 
                    retry_count, created_at, updated_at
                ) VALUES (?, ?, ?, ?, 'pending', ?, NOW(), NOW())
            `, [
                newPhoneId,
                originalMessage.recipient,
                originalMessage.message,
                newSimId,
                (originalMessage.retry_count || 0) + 1
            ]);
            
            return result.insertId;
        } catch (error) {
            console.error(`‚ùå Erreur lors de la cr√©ation du nouveau message sur autre t√©l√©phone:`, error);
            throw error;
        }
    }

    /**
     * Marque un message comme √©chec final
     */
    async markMessageAsFinalFailure(messageId, reason) {
        try {
            await pool.query(`
                UPDATE sms_history 
                SET status = 'failed', 
                    failure_reason = ?,
                    updated_at = NOW()
                WHERE id = ?
            `, [reason, messageId]);
            
            console.log(`‚õî Message ${messageId} marqu√© comme √©chec final: ${reason}`);
            
        } catch (error) {
            console.error(`‚ùå Erreur lors du marquage √©chec final:`, error);
        }
    }

    // FONCTIONS SUPPRIM√âES: getRetryStrategy et getMaxRetries
    // Le syst√®me simplifi√© n'utilise plus de strat√©gies complexes

    /**
     * D√©finit imm√©diatement une nouvelle SIM par d√©faut apr√®s une d√©faillance
     * Cherche parmi TOUTES les SIMs d√©j√† actives, peu importe le t√©l√©phone
     */
    async setNewDefaultSimAfterFailure(phoneId, failedSimId) {
        try {
            console.log(`üîÑ Recherche d'une SIM D√âJ√Ä ACTIVE pour remplacer SIM ${failedSimId} comme par d√©faut`);
            
            // D'abord, retirer le statut par d√©faut de toutes les SIMs
            await pool.execute('UPDATE sims SET is_default = 0');
            
            // Chercher n'importe quelle SIM D√âJ√Ä ACTIVE (peu importe le t√©l√©phone)
            const [activeSims] = await pool.execute(`
                SELECT id, phone_number, carrier_name, phone_id 
                FROM sims 
                WHERE id != ? AND is_active = 1 
                ORDER BY id ASC 
                LIMIT 1
            `, [failedSimId]);
            
            if (activeSims.length > 0) {
                const newDefaultSim = activeSims[0];
                await pool.execute(
                    'UPDATE sims SET is_default = 1 WHERE id = ?',
                    [newDefaultSim.id]
                );
                console.log(`‚úÖ Nouvelle SIM par d√©faut: ${newDefaultSim.id} (${newDefaultSim.phone_number || 'N/A'} ${newDefaultSim.carrier_name}) - D√âJ√Ä ACTIVE sur t√©l√©phone ${newDefaultSim.phone_id}`);
                return newDefaultSim.id;
            }
            
            console.log(`‚ö†Ô∏è Aucune SIM d√©j√† active trouv√©e pour remplacer SIM ${failedSimId}`);
            return null;
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la d√©finition nouvelle SIM par d√©faut:`, error);
            return null;
        }
    }

    /**
     * R√©cup√®re un message par son ID
     */
    async getMessageById(messageId) {
        try {
            const [messages] = await pool.query(`
                SELECT * FROM sms_history WHERE id = ?
            `, [messageId]);
            
            return messages.length > 0 ? messages[0] : null;
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la r√©cup√©ration du message:`, error);
            return null;
        }
    }

    /**
     * Incr√©mente le compteur de retry
     */
    async incrementRetryCount(messageId) {
        try {
            await pool.query(`
                UPDATE sms_history 
                SET retry_count = retry_count + 1,
                    updated_at = NOW()
                WHERE id = ?
            `, [messageId]);
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de l'incr√©mentation retry:`, error);
        }
    }

    /**
     * Met √† jour la SIM d'un message
     */
    async updateMessageSim(messageId, newSimId) {
        try {
            await pool.query(`
                UPDATE sms_history 
                SET sim_id = ?,
                    status = 'pending',
                    updated_at = NOW()
                WHERE id = ?
            `, [newSimId, messageId]);
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la mise √† jour SIM:`, error);
        }
    }

    /**
     * Met √† jour le t√©l√©phone et la SIM d'un message
     */
    async updateMessagePhone(messageId, newPhoneId, newSimId) {
        try {
            await pool.query(`
                UPDATE sms_history 
                SET phone_id = ?,
                    sim_id = ?,
                    status = 'pending',
                    updated_at = NOW()
                WHERE id = ?
            `, [newPhoneId, newSimId, messageId]);
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la mise √† jour t√©l√©phone:`, error);
        }
    }

    /**
     * Remet un message en pending pour retry
     */
    async retryMessage(messageId) {
        try {
            await pool.query(`
                UPDATE sms_history 
                SET status = 'pending',
                    updated_at = NOW()
                WHERE id = ?
            `, [messageId]);
            
            console.log(`üîÑ Message ${messageId} remis en pending pour retry`);
            
        } catch (error) {
            console.error(`‚ùå Erreur lors du retry message:`, error);
        }
    }

    /**
     * D√©marre le syst√®me de monitoring des timeouts
     */
    startTimeoutMonitoring() {
        console.log(`üïê D√©marrage du monitoring des timeouts (v√©rification toutes les 2 minutes)`);
        console.log(`üîç Surveillance renforc√©e des SIMs d√©faillantes (v√©rification toutes les 2 minutes)`);
        
        // Surveillance des messages timeout (toutes les 2 minutes)
        setInterval(() => {
            this.checkTimeoutMessages();
        }, 120000); // 2 minutes
        
        // SURVEILLANCE RENFORC√âE: V√©rification des SIMs d√©faillantes (toutes les 2 minutes)
        setInterval(() => {
            this.checkFailedMessagesForSimDeactivation();
        }, 120000); // 2 minutes
        
        // V√©rification p√©riodique des SIMs par d√©faut multiples (toutes les heures)
        setInterval(() => {
            this.checkAndFixMultipleDefaults();
        }, 3600000); // 1 heure
    }

    /**
     * V√©rifie les messages en timeout
     */
    async checkTimeoutMessages() {
        try {
            // CORRECTION: Traiter TOUS les messages en pending depuis plus d'1 minute
            // Sans limite de retry_count pour capturer les messages de retry
            const [timeoutMessages] = await pool.query(`
                SELECT id, phone_id, sim_id, recipient, retry_count, created_at
                FROM sms_history 
                WHERE status = 'pending' 
                AND created_at < DATE_SUB(NOW(), INTERVAL 1 MINUTE)
                ORDER BY created_at ASC
            `);

            console.log(`üïê V√©rification timeout: ${timeoutMessages.length} messages en attente d√©tect√©s`);

            for (const message of timeoutMessages) {
                console.log(`‚è∞ Timeout d√©tect√© pour message ${message.id} (retry_count: ${message.retry_count}, cr√©√©: ${message.created_at})`);
                
                // Traiter le timeout - cela va d√©sactiver la SIM et cr√©er un nouveau message si possible
                await this.handleFailedMessage(message.id, 'TIMEOUT', message.phone_id, message.sim_id);
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la v√©rification des timeouts:`, error);
        }
    }

    // FONCTION SUPPRIM√âE: checkAndDeactivateFailingSim
    // Le syst√®me de seuils a √©t√© d√©sactiv√© - d√©sormais d√©sactivation syst√©matique √† chaque √©chec

    // FONCTIONS SUPPRIM√âES: activateAlternativeDefaultSim et logSimDeactivation
    // Ces fonctions √©taient li√©es au syst√®me de seuils qui a √©t√© d√©sactiv√©

    /**
     * V√©rifie s'il reste des SIMs disponibles pour retry
     */
    async hasAvailableSimsForRetry(message) {
        try {
            // Compter toutes les SIMs actives disponibles
            const [allActiveSims] = await pool.query(`
                SELECT COUNT(*) as total_active_sims
                FROM sims s
                JOIN phones p ON s.phone_id = p.id
                WHERE s.is_active = 1 AND p.status = 'active'
            `);

            // Compter les SIMs qui ont d√©j√† √©t√© test√©es pour ce message r√©cemment
            const [testedSims] = await pool.query(`
                SELECT COUNT(DISTINCT sim_id) as tested_sims
                FROM sms_history
                WHERE recipient = ? 
                AND created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR)
                AND status IN ('failed', 'pending')
            `, [message.recipient]);

            const totalActive = allActiveSims[0]?.total_active_sims || 0;
            const alreadyTested = testedSims[0]?.tested_sims || 0;
            const available = totalActive - alreadyTested;

            console.log(`üìä SIMs pour ${message.recipient}: ${totalActive} actives, ${alreadyTested} test√©es, ${available} disponibles`);

            return available > 0;

        } catch (error) {
            console.error(`‚ùå Erreur lors de la v√©rification des SIMs disponibles:`, error);
            return false; // En cas d'erreur, continuer par s√©curit√©
        }
    }

    /**
     * Obtient toutes les SIMs actives non test√©es pour un destinataire
     */
    async getUntestedActiveSims(recipient) {
        try {
            const [untestedSims] = await pool.query(`
                SELECT s.id, s.carrier_name, s.phone_number, s.phone_id
                FROM sims s
                JOIN phones p ON s.phone_id = p.id
                WHERE s.is_active = 1 
                AND p.status = 'active'
                AND s.id NOT IN (
                    SELECT DISTINCT sim_id 
                    FROM sms_history 
                    WHERE recipient = ? 
                    AND created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR)
                    AND status IN ('failed', 'pending')
                    AND sim_id IS NOT NULL
                )
                ORDER BY RAND()
            `, [recipient]);

            console.log(`üîç ${untestedSims.length} SIMs non test√©es trouv√©es pour ${recipient}`);
            return untestedSims;

        } catch (error) {
            console.error(`‚ùå Erreur lors de la r√©cup√©ration des SIMs non test√©es:`, error);
            return [];
        }
    }

    /**
     * SURVEILLANCE RENFORC√âE: V√©rifie et d√©sactive les SIMs d√©faillantes
     */
    async checkFailedMessagesForSimDeactivation() {
        console.log(`üîç Surveillance p√©riodique des SIMs d√©faillantes (toutes les 2 min)...`);
        
        try {
            // SURVEILLANCE RENFORC√âE: Chercher les messages 'failed' r√©cents avec des crit√®res plus larges
            const [failedMessages] = await pool.query(`
                SELECT DISTINCT h.sim_id, MAX(h.id) as latest_message_id, MAX(h.created_at) as latest_failure, 
                       s.phone_number, s.carrier_name, s.phone_id, COUNT(h.id) as failure_count,
                       MIN(h.created_at) as first_failure
                FROM sms_history h
                JOIN sims s ON h.sim_id = s.id
                WHERE h.status = 'failed' 
                AND h.created_at > DATE_SUB(NOW(), INTERVAL 30 MINUTE)  -- √âlargi √† 30 minutes
                AND s.is_active = 1
                GROUP BY h.sim_id, s.phone_number, s.carrier_name, s.phone_id
                ORDER BY failure_count DESC, latest_failure DESC
            `);

            // SURVEILLANCE SUPPL√âMENTAIRE: Chercher les messages 'pending' trop anciens (probablement √©chou√©s)
            const [stuckMessages] = await pool.query(`
                SELECT DISTINCT h.sim_id, MAX(h.id) as latest_message_id, MAX(h.created_at) as latest_stuck, 
                       s.phone_number, s.carrier_name, s.phone_id, COUNT(h.id) as stuck_count
                FROM sms_history h
                JOIN sims s ON h.sim_id = s.id
                WHERE h.status = 'pending' 
                AND h.created_at < DATE_SUB(NOW(), INTERVAL 5 MINUTE)  -- Messages bloqu√©s depuis 5+ minutes
                AND s.is_active = 1
                GROUP BY h.sim_id, s.phone_number, s.carrier_name, s.phone_id
                HAVING stuck_count >= 2  -- Au moins 2 messages bloqu√©s
                ORDER BY stuck_count DESC, latest_stuck DESC
            `);

            const totalProblematicSims = failedMessages.length + stuckMessages.length;
            
            if (totalProblematicSims > 0) {
                console.log(`üö® ${totalProblematicSims} SIM(s) probl√©matique(s) d√©tect√©e(s):`);
                
                // Traiter les SIMs avec des √©checs explicites
                for (const msg of failedMessages) {
                    console.log(`   - SIM ${msg.sim_id} (${msg.phone_number || 'N/A'} ${msg.carrier_name} sur ${msg.phone_id}): ${msg.failure_count} √©chec(s) explicite(s)`);
                    
                    // V√©rifier si la SIM est exclue du monitoring avant de la d√©sactiver
                    const [simInfo] = await pool.execute(
                        'SELECT excluded_from_monitoring FROM sims WHERE id = ?',
                        [msg.sim_id]
                    );
                    
                    if (simInfo.length > 0 && simInfo[0].excluded_from_monitoring === 1) {
                        console.log(`üõ°Ô∏è SIM ${msg.sim_id} exclue du monitoring - d√©sactivation automatique ignor√©e`);
                    } else {
                        // D√©sactiver imm√©diatement cette SIM
                        await pool.execute(
                            'UPDATE sims SET is_active = 0, is_default = 0 WHERE id = ?',
                            [msg.sim_id]
                        );
                        
                        console.log(`‚ùå SIM ${msg.sim_id} d√©sactiv√©e automatiquement (√©checs explicites)`);
                    }
                    
                    // Marquer les messages pending de cette SIM comme failed
                    await pool.execute(`
                        UPDATE sms_history 
                        SET status = 'failed', failure_reason = 'SIM_AUTO_DEACTIVATED' 
                        WHERE sim_id = ? AND status = 'pending'
                    `, [msg.sim_id]);
                }
                
                // Traiter les SIMs avec des messages bloqu√©s
                for (const msg of stuckMessages) {
                    console.log(`   - SIM ${msg.sim_id} (${msg.phone_number || 'N/A'} ${msg.carrier_name} sur ${msg.phone_id}): ${msg.stuck_count} message(s) bloqu√©(s)`);
                    
                    // V√©rifier si la SIM est exclue du monitoring avant de la d√©sactiver
                    const [simInfo] = await pool.execute(
                        'SELECT excluded_from_monitoring FROM sims WHERE id = ?',
                        [msg.sim_id]
                    );
                    
                    if (simInfo.length > 0 && simInfo[0].excluded_from_monitoring === 1) {
                        console.log(`üõ°Ô∏è SIM ${msg.sim_id} exclue du monitoring - d√©sactivation automatique ignor√©e (messages bloqu√©s)`);
                    } else {
                        // D√©sactiver cette SIM aussi
                        await pool.execute(
                            'UPDATE sims SET is_active = 0, is_default = 0 WHERE id = ?',
                            [msg.sim_id]
                        );
                        
                        console.log(`‚ùå SIM ${msg.sim_id} d√©sactiv√©e automatiquement (messages bloqu√©s)`);
                    }
                    
                    // Marquer les messages pending de cette SIM comme failed
                    await pool.execute(`
                        UPDATE sms_history 
                        SET status = 'failed', failure_reason = 'SIM_STUCK_MESSAGES' 
                        WHERE sim_id = ? AND status = 'pending'
                    `, [msg.sim_id]);
                }
                
                // S'assurer qu'il reste au moins une SIM active
                await this.ensureAtLeastOneActiveSim();
                
            } else {
                console.log(`‚úÖ Aucune SIM probl√©matique d√©tect√©e`);
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la surveillance des SIMs d√©faillantes:`, error);
        }
    }
    
    /**
     * S'assure qu'il reste au moins une SIM active dans le syst√®me
     */
    async ensureAtLeastOneActiveSim() {
        try {
            // V√©rifier s'il reste des SIMs actives
            const [activeSims] = await pool.query('SELECT COUNT(*) as count FROM sims WHERE is_active = 1');
            
            if (activeSims[0].count === 0) {
                console.warn(`‚ö†Ô∏è ALERTE: Aucune SIM active restante! R√©activation d'urgence...`);
                
                // R√©activer la SIM la plus r√©cemment utilis√©e avec succ√®s
                const [lastSuccessfulSim] = await pool.query(`
                    SELECT s.id, s.phone_number, s.carrier_name 
                    FROM sims s
                    JOIN sms_history h ON s.id = h.sim_id
                    WHERE h.status IN ('sent', 'delivered')
                    ORDER BY h.created_at DESC
                    LIMIT 1
                `);
                
                if (lastSuccessfulSim.length > 0) {
                    const simToReactivate = lastSuccessfulSim[0];
                    await pool.execute(
                        'UPDATE sims SET is_active = 1, is_default = 1 WHERE id = ?',
                        [simToReactivate.id]
                    );
                    console.log(`üîÑ SIM ${simToReactivate.id} (${simToReactivate.phone_number}) r√©activ√©e d'urgence`);
                } else {
                    // En dernier recours, r√©activer la premi√®re SIM disponible
                    const [firstSim] = await pool.query('SELECT id, phone_number, carrier_name FROM sims ORDER BY id LIMIT 1');
                    if (firstSim.length > 0) {
                        await pool.execute(
                            'UPDATE sims SET is_active = 1, is_default = 1 WHERE id = ?',
                            [firstSim[0].id]
                        );
                        console.log(`üîÑ SIM ${firstSim[0].id} (${firstSim[0].phone_number}) r√©activ√©e par d√©faut`);
                    }
                }
            }
        } catch (error) {
            console.error(`‚ùå Erreur lors de la v√©rification des SIMs actives:`, error);
        }
    }
    
    /**
     * V√©rifie et corrige les SIMs par d√©faut multiples
     */
    async checkAndFixMultipleDefaults() {
        try {
            console.log(`üîç V√©rification des SIMs par d√©faut multiples...`);
            
            // Chercher les SIMs par d√©faut multiples
            const [defaultSims] = await pool.query(`
                SELECT id, phone_number, carrier_name, phone_id 
                FROM sims 
                WHERE is_default = 1 
                ORDER BY id
            `);
            
            if (defaultSims.length > 1) {
                console.warn(`‚ö†Ô∏è ${defaultSims.length} SIMs par d√©faut d√©tect√©es! Correction en cours...`);
                
                // Garder seulement la premi√®re SIM par d√©faut active
                const simToKeep = defaultSims.find(sim => sim.is_active) || defaultSims[0];
                
                // D√©sactiver toutes les autres SIMs par d√©faut
                for (const sim of defaultSims) {
                    if (sim.id !== simToKeep.id) {
                        await pool.execute(
                            'UPDATE sims SET is_default = 0 WHERE id = ?',
                            [sim.id]
                        );
                        console.log(`üîß SIM ${sim.id} (${sim.phone_number}) n'est plus par d√©faut`);
                    }
                }
                
                console.log(`‚úÖ SIM ${simToKeep.id} (${simToKeep.phone_number}) reste la seule par d√©faut`);
                
            } else if (defaultSims.length === 1) {
                console.log(`‚úÖ Une seule SIM par d√©faut: ${defaultSims[0].phone_number}`);
            } else {
                console.warn(`‚ö†Ô∏è Aucune SIM par d√©faut! D√©finition automatique...`);
                
                // D√©finir une SIM active comme par d√©faut
                const [activeSims] = await pool.query(`
                    SELECT id, phone_number, carrier_name 
                    FROM sims 
                    WHERE is_active = 1 
                    ORDER BY id 
                    LIMIT 1
                `);
                
                if (activeSims.length > 0) {
                    await pool.execute(
                        'UPDATE sims SET is_default = 1 WHERE id = ?',
                        [activeSims[0].id]
                    );
                    console.log(`üîß SIM ${activeSims[0].id} (${activeSims[0].phone_number}) d√©finie comme par d√©faut`);
                }
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur lors de la v√©rification des SIMs par d√©faut:`, error);
        }
    }
}

module.exports = SmartRetrySystem;
























